&ANALYZE-SUSPEND _VERSION-NUMBER AB_v10r12
&ANALYZE-RESUME
{adecomm/appserv.i}
DEFINE VARIABLE h_Astra                    AS HANDLE          NO-UNDO.
&ANALYZE-SUSPEND _UIB-CODE-BLOCK _XFTR "Check Version Notes Wizard" DataLogicProcedure _INLINE
/*************************************************************/  
/* Copyright (c) 1984-2005 by Progress Software Corporation  */
/*                                                           */
/* All rights reserved.  No part of this program or document */
/* may be  reproduced in  any form  or by  any means without */
/* permission in writing from PROGRESS Software Corporation. */
/*************************************************************/
/* Actions: af/cod/aftemwizcw.w ? ? ? ? */
/* MIP Update Version Notes Wizard
Check object version notes.
af/cod/aftemwizpw.w
*/
/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _XFTR "Update-Object-Version" DataLogicProcedure _INLINE
/* Actions: ? ? ? ? af/sup/afverxftrp.p */
/* This has to go above the definitions sections, as that is what it modifies.
   If its not, then the definitions section will have been saved before the
   XFTR code kicks in and changes it */
/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _XFTR "Definition Comments Wizard" DataLogicProcedure _INLINE
/* Actions: ? af/cod/aftemwizcw.w ? ? ? */
/* Program Definition Comment Block Wizard
Welcome to the Program Definition Comment Block Wizard. Press Next to proceed.
af/cod/aftemwizpw.w
*/
/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CUSTOM _DEFINITIONS DataLogicProcedure 
/*---------------------------------------------------------------------------------
  File: rytemdlprocedure.p

  Description:  Data Logic Procedure Library Template

  Purpose:      A procedure library (PLIP) to support the maintenance of the data-logic table
                The following internal procedures may be added or modified
                to act as validation to creation, modification, or deletion of
                records in the database table
                
                Client-side:
                rowObjectValidate***
                
                Server-side upon create:
                createPreTransValidate***
                createBeginTransValidate
                createEndTransValidate
                createPostTransValidate
                
                Server-side upon write (create and modify):
                writePreTransValidate***
                writeBeginTransValidate
                writeEndTransValidate
                writePostTransValidate
                
                Server-side upon delete:
                deletePreTransValidate
                deleteBeginTransValidate
                deleteEndTransValidate
                deletePostTransValidate
                
                *** The rowObjectValidate, createPreTransValidate and writePreTransValidate
                internal procedures are automatically generated by the SDO generator

  Parameters:

  History:
  --------
  ---------------------------------------------------------------------------------*/
/*                   This .W file was created with the Progress UIB.             */
/*-------------------------------------------------------------------------------*/

/* ***************************  Definitions  ************************** */
/* MIP-GET-OBJECT-VERSION pre-processors
   The following pre-processors are maintained automatically when the object is
   saved. They pull the object and version from SCM if possible so that it
   can be displayed in the about window of the container */

&scop object-name       rydfdatalog.p
DEFINE VARIABLE lv_this_object_name AS CHARACTER INITIAL "{&object-name}":U NO-UNDO.
&scop object-version    000000

/* object identifying preprocessor */
&glob   AstraPlip    yes

DEFINE VARIABLE cObjectName         AS CHARACTER NO-UNDO.

ASSIGN cObjectName = "{&object-name}":U.

&scop   mip-notify-user-on-plip-close   NO


/* Error handling definitions */
{checkerr.i &define-only = YES}

{ry/inc/rydfttdef.i}     /* Defines ryttDataField temp table */
{ry/inc/ryrepatset.i}    /* Defines the store attribute table */
{destdefi.i}             /* Definitions for dynamics design-time temp-tables. */

DEFINE TEMP-TABLE DeleteAttribute LIKE ttStoreAttribute.

DEFINE TEMP-TABLE ttdpsAttr
    FIELD tLabel     AS CHARACTER
    FIELD tDataType  AS CHARACTER
    FIELD tValue     AS CHARACTER.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


&ANALYZE-SUSPEND _UIB-PREPROCESSOR-BLOCK 

/* ********************  Preprocessor Definitions  ******************** */

&Scoped-define PROCEDURE-TYPE DataLogicProcedure
&Scoped-define DB-AWARE yes


/* Db-Required definitions. */
&IF DEFINED(DB-REQUIRED) = 0 &THEN
    &GLOBAL-DEFINE DB-REQUIRED TRUE
&ENDIF
&GLOBAL-DEFINE DB-REQUIRED-START   &IF {&DB-REQUIRED} &THEN
&GLOBAL-DEFINE DB-REQUIRED-END     &ENDIF


&Global-define DATA-LOGIC-TABLE ryttDataField
&Global-define DATA-FIELD-DEFS "ry/obj/rydfdatao.i"
&Global-define DATA-TABLE-NO-UNDO NO-UNDO


/* _UIB-PREPROCESSOR-BLOCK-END */
&ANALYZE-RESUME


/* ************************  Function Prototypes ********************** */

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION-FORWARD isFieldBlank DataLogicProcedure 
FUNCTION isFieldBlank RETURNS LOGICAL
  ( INPUT pcFieldValue AS CHARACTER )  FORWARD.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


/* *********************** Procedure Settings ************************ */

&ANALYZE-SUSPEND _PROCEDURE-SETTINGS
/* Settings for THIS-PROCEDURE
   Type: DataLogicProcedure
   Allow: 
   Frames: 0
   Add Fields to: Neither
   Other Settings: CODE-ONLY COMPILE APPSERVER DB-AWARE
 */
&ANALYZE-RESUME _END-PROCEDURE-SETTINGS

/* *************************  Create Window  ************************** */

&ANALYZE-SUSPEND _CREATE-WINDOW
/* DESIGN Window definition (used by the UIB) 
  CREATE WINDOW DataLogicProcedure ASSIGN
         HEIGHT             = 11.76
         WIDTH              = 62.2.
/* END WINDOW DEFINITION */
                                                                        */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CUSTOM _INCLUDED-LIB DataLogicProcedure 
/* ************************* Included-Libraries *********************** */

{src/adm2/logic.i}

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


 


&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CUSTOM _MAIN-BLOCK DataLogicProcedure 


/* ***************************  Main Block  ******************************* */

{ry/app/ryplipmain.i}

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME


/* **********************  Internal Procedures  *********************** */

{&DB-REQUIRED-START}

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE deleteBeginTransValidate DataLogicProcedure  _DB-REQUIRED
PROCEDURE deleteBeginTransValidate :
/*------------------------------------------------------------------------------
  Purpose:     Procedure to delete field master objects and their instances 
               from their entity
  Parameters:  <none>
  Notes:       
------------------------------------------------------------------------------*/
DEFINE VARIABLE cEntityName       AS CHARACTER  NO-UNDO.
DEFINE VARIABLE hContainersource  AS HANDLE     NO-UNDO.
DEFINE VARIABLE hDataSource       AS HANDLE     NO-UNDO.
DEFINE VARIABLE hRepDesignManager AS HANDLE     NO-UNDO.

  ASSIGN 
    hContainerSource = DYNAMIC-FUNCTION('getContainerSource':U IN TARGET-PROCEDURE)
    hDataSource      = DYNAMIC-FUNCTION('getDataSource':U IN hContainerSource)
    hRepDesignManager = DYNAMIC-FUNCTION('getManagerHandle':U, INPUT 'RepositoryDesignManager':U) NO-ERROR.

  IF VALID-HANDLE(hDataSource) THEN
    cEntityName = DYNAMIC-FUNCTION('columnValue':U IN hDataSource,
                                      INPUT 'entity_mnemonic_description':U).

  /* Remove instance from entity */
  RUN removeObjectInstance IN hRepDesignManager
      (INPUT cEntityName,
       INPUT '':U,
       INPUT b_ryttDataField.tFieldName,
       INPUT b_ryttDataField.tInstanceName,
       INPUT '':U) NO-ERROR.

  IF RETURN-VALUE <> '':U OR ERROR-STATUS:ERROR THEN
  DO:
    ERROR-STATUS:ERROR = NO.
    RETURN RETURN-VALUE.
  END.

  /* Remove master object - suppress any errors returned, the object could be in use on another 
     container.  There is currently no repository API to return whether an object is used on 
     a container.  This should be modified when that API becomes available to check whether the 
     object is used on a container before attempting to delete it */
  RUN removeObject IN hRepDesignManager
             (INPUT b_ryttDataField.tFieldName,
              INPUT '':U) NO-ERROR.

  IF RETURN-VALUE <> '':U OR ERROR-STATUS:ERROR THEN
  DO:
    ERROR-STATUS:ERROR = NO.
    RETURN ''.
  END.

END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

{&DB-REQUIRED-END}

{&DB-REQUIRED-START}

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE initializeObject DataLogicProcedure  _DB-REQUIRED
PROCEDURE initializeObject :
/*------------------------------------------------------------------------------
  Purpose:     initializeObject override
  Parameters:  <none>
  Notes:       
------------------------------------------------------------------------------*/
DEFINE VARIABLE cMasterName      AS CHARACTER  NO-UNDO.
DEFINE VARIABLE hContainerSource AS HANDLE     NO-UNDO.
DEFINE VARIABLE hDataSource      AS HANDLE     NO-UNDO.

  ASSIGN 
    hContainerSource = DYNAMIC-FUNCTION('getContainerSource':U IN TARGET-PROCEDURE)
    hDataSource      = DYNAMIC-FUNCTION('getDataSource':U IN hContainerSource).

  /* Subscribe to populate related data if there is a valid data source, it needs
     to subscribe to populateRelatedData in both its data source and container source.
     This object is based on temp tables and is not linked to the parent entity SDO.  
     The entity SDO publishes populateRelatedData in its dataAvailable.  The entity 
     viewer publishes populateRelatedData in its container source in its dataAvailable.
     If there is not a valid data source, subscribe to populateMasterData, this is published 
     from a container maintaining one datafield master object. */
  IF VALID-HANDLE(hDataSource) THEN
  DO:
    SUBSCRIBE PROCEDURE TARGET-PROCEDURE TO 'populateRelatedData':U IN hContainerSource.
    SUBSCRIBE PROCEDURE TARGET-PROCEDURE TO 'populateRelatedData':U IN hDataSource.
  END.
  ELSE SUBSCRIBE PROCEDURE TARGET-PROCEDURE TO 'populateMasterData':U IN hContainerSource.

  RUN SUPER.

  IF VALID-HANDLE(hDataSource) THEN
    RUN populateRelatedData IN TARGET-PROCEDURE.

END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

{&DB-REQUIRED-END}

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE killPlip DataLogicProcedure 
PROCEDURE killPlip :
/*------------------------------------------------------------------------------
  Purpose:     entry point to instantly kill the plip if it should get lost in memory
  Parameters:  <none>
  Notes:       
------------------------------------------------------------------------------*/

  {ry/app/ryplipkill.i}

END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE objectDescription DataLogicProcedure 
PROCEDURE objectDescription :
/*------------------------------------------------------------------------------
  Purpose:     Pass out a description of the PLIP, used in Plip temp-table
  Parameters:  <none>
  Notes:       This should be changed manually for each plip
------------------------------------------------------------------------------*/

  DEFINE OUTPUT PARAMETER cDescription AS CHARACTER NO-UNDO.

  ASSIGN cDescription = "Datafield maintenance SDO data logic procedure".

END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE plipSetup DataLogicProcedure 
PROCEDURE plipSetup :
/*------------------------------------------------------------------------------
  Purpose:    Run by main-block of PLIP at startup of PLIP
  Parameters: <none>
  Notes:       
------------------------------------------------------------------------------*/

  {ry/app/ryplipsetu.i}  

END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE plipShutdown DataLogicProcedure 
PROCEDURE plipShutdown :
/*------------------------------------------------------------------------------
  Purpose:     This procedure will be run just before the calling program 
               terminates
  Parameters:  <none>
  Notes:       
------------------------------------------------------------------------------*/

  {ry/app/ryplipshut.i}

END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

{&DB-REQUIRED-START}

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE populateMasterData DataLogicProcedure  _DB-REQUIRED
PROCEDURE populateMasterData :
/*------------------------------------------------------------------------------
  Purpose:     Creates temp table record for a single master datafield object
  Parameters:  <none>
  Notes:       
------------------------------------------------------------------------------*/
DEFINE VARIABLE cInheritClasses   AS CHARACTER  NO-UNDO.
DEFINE VARIABLE cMasterName       AS CHARACTER  NO-UNDO.
DEFINE VARIABLE cTempTableNames   AS CHARACTER  NO-UNDO INITIAL
    "tDataType,tLabel,tFormat,tColumnLabel,tSchemaValMsg,tSchemaValExp,tSchemaViewAs,tSchemaColumnLabel,tSchemaFormat,tSchemaHelp,tSchemaInitial,tSchemaLabel,tIncludeView,tIncludeListView,tDefaultValue".
DEFINE VARIABLE cViewerAttributes AS CHARACTER  NO-UNDO INITIAL 
    "Data-Type,Label,Format,ColumnLabel,SCHEMA-VALIDATE-MESSAGE,SCHEMA-VALIDATE-EXPRESSION,SCHEMA-VIEW-AS,SCHEMA-COLUMN-LABEL,SCHEMA-FORMAT,SCHEMA-HELP,SCHEMA-INITIAL,SCHEMA-LABEL,IncludeInDefaultView,IncludeInDefaultListView,DefaultValue".
DEFINE VARIABLE hContainerSource  AS HANDLE     NO-UNDO.
DEFINE VARIABLE hDataField        AS HANDLE     NO-UNDO.
DEFINE VARIABLE hRepDesignManager AS HANDLE     NO-UNDO.
DEFINE VARIABLE iEntry            AS INTEGER    NO-UNDO.

  ASSIGN
    hContainerSource = DYNAMIC-FUNCTION('getContainerSource':U IN TARGET-PROCEDURE)
    cMasterName      = DYNAMIC-FUNCTION('getMasterName':U IN hContainerSource)
    hDataField       = DYNAMIC-FUNCTION('getTempTableBuffer':U IN TARGET-PROCEDURE).

  hDataField:EMPTY-TEMP-TABLE().
                   
  hRepDesignManager = DYNAMIC-FUNCTION('getManagerHandle':U, INPUT 'RepositoryDesignManager':U) NO-ERROR.
  RUN retrieveDesignObject IN hRepDesignManager
      (INPUT cMasterName,
       INPUT '':U,              /* Default result codes */
       OUTPUT TABLE ttObject,
       OUTPUT TABLE ttPage,
       OUTPUT TABLE ttLink,
       OUTPUT TABLE ttUIEvent,
       OUTPUT TABLE ttObjectAttribute).

  FIND FIRST ttObject WHERE ttObject.tLogicalObjectName = cMasterName NO-ERROR.
  IF AVAILABLE ttObject THEN
  
    hDataField:BUFFER-CREATE().
    ASSIGN 
      hDataField:BUFFER-FIELD('tClassName':U):BUFFER-VALUE     = ttObject.tClassName
      hDataField:BUFFER-FIELD('tFieldName':U):BUFFER-VALUE     = ttObject.tLogicalObjectname
      hDataField:BUFFER-FIELD('tProductModule':U):BUFFER-VALUE = ttObject.tProductModuleCode
      hDataField:BUFFER-FIELD('tEditMaster':U):BUFFER-VALUE    = 'YES':U.
    
    RUN retrieveDesignClass IN hRepDesignManager
                          ( INPUT  ttObject.tClassName,
                            OUTPUT cInheritClasses,
                            OUTPUT TABLE ttClassAttribute ,
                            OUTPUT TABLE ttUiEvent,
                            OUTPUT TABLE ttSupportedLink    ) NO-ERROR.     

    AttributeLoop:
    FOR EACH ttClassAttribute:
      iEntry = 0.
      /* Get the attribute value stored on the datafield master */   
      FIND ttObjectAttribute WHERE ttObjectAttribute.tSmartObjectObj    = ttObject.tSmartobjectObj 
                               AND ttObjectAttribute.tObjectInstanceObj = 0
                               AND ttObjectAttribute.tAttributeLabel    = ttClassAttribute.tAttributeLabel NO-ERROR.

      iEntry = LOOKUP(ttClassAttribute.tAttributeLabel, cViewerAttributes).
      IF iEntry > 0 THEN
        ASSIGN hDataField:BUFFER-FIELD(ENTRY(iEntry, cTempTableNames)):BUFFER-VALUE = IF AVAILABLE ttObjectAttribute 
                                                                                      THEN ttObjectAttribute.tAttributeValue
                                                                                      ELSE ttClassAttribute.tAttributeValue.
    END.  /* attribute loop */

    IF hDataField:BUFFER-FIELD('tIncludeListView':U):BUFFER-VALUE = ? THEN
      hDataField:BUFFER-FIELD('tIncludeListView':U):BUFFER-VALUE = hDataField:BUFFER-FIELD('tIncludeView':U):BUFFER-VALUE.

  DYNAMIC-FUNCTION('openQuery':U IN TARGET-PROCEDURE).

END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

{&DB-REQUIRED-END}

{&DB-REQUIRED-START}

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE populateRelatedData DataLogicProcedure  _DB-REQUIRED
PROCEDURE populateRelatedData :
/*------------------------------------------------------------------------------
  Purpose:     Creates temp table records for all datafield instances of an entity
  Parameters:  <none>
  Notes:       
------------------------------------------------------------------------------*/
DEFINE VARIABLE cEntityName       AS CHARACTER  NO-UNDO.
DEFINE VARIABLE cInheritClasses   AS CHARACTER  NO-UNDO.
DEFINE VARIABLE cTempTableNames   AS CHARACTER  NO-UNDO INITIAL
    "tDataType,tLabel,tFormat,tColumnLabel,tSchemaValMsg,tSchemaValExp,tSchemaViewAs,tSchemaColumnLabel,tSchemaFormat,tSchemaHelp,tSchemaInitial,tSchemaLabel,tIncludeView,tIncludeListView,tDefaultValue".
DEFINE VARIABLE cViewerAttributes AS CHARACTER  NO-UNDO INITIAL 
    "Data-Type,Label,Format,ColumnLabel,SCHEMA-VALIDATE-MESSAGE,SCHEMA-VALIDATE-EXPRESSION,SCHEMA-VIEW-AS,SCHEMA-COLUMN-LABEL,SCHEMA-FORMAT,SCHEMA-HELP,SCHEMA-INITIAL,SCHEMA-LABEL,IncludeInDefaultView,IncludeInDefaultListView,DefaultValue".
DEFINE VARIABLE hContainerSource  AS HANDLE     NO-UNDO.
DEFINE VARIABLE hDataSource       AS HANDLE     NO-UNDO.
DEFINE VARIABLE hDataField        AS HANDLE     NO-UNDO.
DEFINE VARIABLE hRepDesignManager AS HANDLE     NO-UNDO.
DEFINE VARIABLE iEntry            AS INTEGER    NO-UNDO.

  DYNAMIC-FUNCTION('closeQuery':U IN TARGET-PROCEDURE).

  ASSIGN 
    hContainerSource = DYNAMIC-FUNCTION('getContainerSource':U IN TARGET-PROCEDURE)
    hDataSource      = DYNAMIC-FUNCTION('getDataSource':U IN hContainerSource)
    hDataField       = DYNAMIC-FUNCTION('getTempTableBuffer':U IN TARGET-PROCEDURE).

  hDataField:EMPTY-TEMP-TABLE().

  IF VALID-HANDLE(hDataSource) THEN
    cEntityName = DYNAMIC-FUNCTION('columnValue':U IN hDataSource,
                                      INPUT 'entity_mnemonic_description':U).
  
  hRepDesignManager = DYNAMIC-FUNCTION('getManagerHandle':U, INPUT 'RepositoryDesignManager':U) NO-ERROR.
  RUN retrieveDesignObject IN hRepDesignManager
      (INPUT cEntityName,
       INPUT '':U,              /* Default result codes */
       OUTPUT TABLE ttObject,
       OUTPUT TABLE ttPage,
       OUTPUT TABLE ttLink,
       OUTPUT TABLE ttUIEvent,
       OUTPUT TABLE ttObjectAttribute).

  InstanceLoop:
  FOR EACH ttObject WHERE ttObject.tContainerSmartObjectObj > 0:
    IF NOT CAN-FIND(FIRST ttClassAttribute WHERE ttClassAttribute.tClassname = ttObject.tClassName) OR 
       cInheritClasses = '':U THEN
      RUN retrieveDesignClass IN hRepDesignManager
                            ( INPUT  ttObject.tClassName,
                              OUTPUT cInheritClasses,
                              OUTPUT TABLE ttClassAttribute ,
                              OUTPUT TABLE ttUiEvent,
                              OUTPUT TABLE ttSupportedLink    ) NO-ERROR.       
  
    IF LOOKUP("DataField":U, cInheritClasses) > 0 THEN 
    DO:
      hDataField:BUFFER-CREATE().
      ASSIGN 
        hDataField:BUFFER-FIELD('tClassName':U):BUFFER-VALUE     = ttObject.tClassName
        hDataField:BUFFER-FIELD('tFieldName':U):BUFFER-VALUE     = ttObject.tLogicalObjectname
        hDataField:BUFFER-FIELD('tInstanceName':U):BUFFER-VALUE  = ttObject.tObjectInstanceName
        hDataField:BUFFER-FIELD('tInstanceOrder':U):BUFFER-VALUE = ttObject.tPageObjectSequence
        hDataField:BUFFER-FIELD('tProductModule':U):BUFFER-VALUE = ttObject.tProductModuleCode
        hDataField:BUFFER-FIELD('tEditMaster':U):BUFFER-VALUE    = 'YES':U.

      AttributeLoop:
      FOR EACH ttClassAttribute:
        iEntry = 0.
        /* Get the attribute value stored on the datafield master */   
        FIND ttObjectAttribute WHERE ttObjectAttribute.tSmartObjectObj    = ttObject.tSmartobjectObj 
                                 AND ttObjectAttribute.tObjectInstanceObj = 0
                                 AND ttObjectAttribute.tAttributeLabel    = ttClassAttribute.tAttributeLabel NO-ERROR.
        
        iEntry = LOOKUP(ttClassAttribute.tAttributeLabel, cViewerAttributes).
        IF iEntry > 0 THEN
          ASSIGN hDataField:BUFFER-FIELD(ENTRY(iEntry, cTempTableNames)):BUFFER-VALUE = IF AVAILABLE ttObjectAttribute 
                                                                                        THEN ttObjectAttribute.tAttributeValue
                                                                                        ELSE ttClassAttribute.tAttributeValue.
      END.  /* attribute loop */

      IF hDataField:BUFFER-FIELD('tIncludeListView':U):BUFFER-VALUE = ? THEN
        hDataField:BUFFER-FIELD('tIncludeListView':U):BUFFER-VALUE = hDataField:BUFFER-FIELD('tIncludeView':U):BUFFER-VALUE.

    END.  /* if datafield */
  END.  /* instance loop */

  DYNAMIC-FUNCTION('openQuery':U IN TARGET-PROCEDURE).

END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

{&DB-REQUIRED-END}

{&DB-REQUIRED-START}

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE setdpsAttr DataLogicProcedure  _DB-REQUIRED
PROCEDURE setdpsAttr :
/*------------------------------------------------------------------------------
  Purpose:     Takes DPS attribute temp-table from datafield maintenance viewer
  Parameters:  <none>
  Notes:       Invoked from updateRecord in viewer
------------------------------------------------------------------------------*/
DEFINE INPUT PARAMETER TABLE FOR ttdpsAttr.
  
END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

{&DB-REQUIRED-END}

{&DB-REQUIRED-START}

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _PROCEDURE writeBeginTransValidate DataLogicProcedure  _DB-REQUIRED
PROCEDURE writeBeginTransValidate :
/*------------------------------------------------------------------------------
  Purpose:     Creates/updates datafield master objects and adds/updates their
               instances on an entity.
  Parameters:  <none>
  Notes:       
------------------------------------------------------------------------------*/
DEFINE VARIABLE cABDesignField        AS CHARACTER  NO-UNDO.
DEFINE VARIABLE cEntityName           AS CHARACTER  NO-UNDO.
DEFINE VARIABLE cInheritClasses       AS HANDLE     NO-UNDO.
DEFINE VARIABLE cInvalidAttrs         AS CHARACTER  NO-UNDO.
DEFINE VARIABLE cMessage              AS CHARACTER  NO-UNDO.
DEFINE VARIABLE cViewerAttrs          AS CHARACTER  NO-UNDO INITIAL
    'Data-Type,Format,Label,ColumnLabel,DefaultValue':U.
DEFINE VARIABLE cUpdatedAttributes    AS CHARACTER  NO-UNDO.
DEFINE VARIABLE cUpdatedAttrValues    AS CHARACTER  NO-UNDO.
DEFINE VARIABLE dDataFieldObj         AS DECIMAL    NO-UNDO.
DEFINE VARIABLE dEntityObj            AS DECIMAL    NO-UNDO.
DEFINE VARIABLE dInstanceObj          AS DECIMAL    NO-UNDO.
DEFINE VARIABLE hContainerSource      AS HANDLE     NO-UNDO.
DEFINE VARIABLE hDataSource           AS HANDLE     NO-UNDO.
DEFINE VARIABLE hDeleteAttribute      AS HANDLE     NO-UNDO.
DEFINE VARIABLE hNewBuffer            AS HANDLE     NO-UNDO.
DEFINE VARIABLE hNewField             AS HANDLE     NO-UNDO.
DEFINE VARIABLE hOldBuffer            AS HANDLE     NO-UNDO.
DEFINE VARIABLE hOldField             AS HANDLE     NO-UNDO.
DEFINE VARIABLE hRepDesignManager     AS HANDLE     NO-UNDO.
DEFINE VARIABLE hStoreAttributeBuffer AS HANDLE     NO-UNDO.
DEFINE VARIABLE hUnknown              AS HANDLE     NO-UNDO.
DEFINE VARIABLE iNum                  AS INTEGER    NO-UNDO.
DEFINE VARIABLE lIncludeListView      AS LOGICAL    NO-UNDO.
define variable lCalculatedField      as logical    no-undo.

  EMPTY TEMP-TABLE ttStoreAttribute.
  EMPTY TEMP-TABLE DeleteAttribute.
    
    /* Figure out if this is a calc field or not. This is used when deciding
       whether to write the TableName attribute or not.
     */
    lCalculatedField = dynamic-function('ClassIsA' in gshRepositoryManager,
                                        b_ryttDataField.tClassName, 'CalculatedField').                       


  hRepDesignManager = DYNAMIC-FUNCTION('getManagerHandle':U, INPUT 'RepositoryDesignManager':U) NO-ERROR.
  /* Only edit master if edit master is chosen */
  IF b_ryttDataField.tEditMaster THEN
  DO:
    RUN retrieveDesignClass IN hRepDesignManager
                      ( INPUT  b_ryttDataField.tClassName,
                        OUTPUT cInheritClasses,
                        OUTPUT TABLE ttClassAttribute ,
                        OUTPUT TABLE ttUiEvent,
                        OUTPUT TABLE ttSupportedLink    ) NO-ERROR.  
                        
    IF b_ryttDataField.RowMod = 'A':U OR b_ryttDataField.RowMod = 'C':U THEN
    DO:
      hNewBuffer = BUFFER b_ryttDataField:HANDLE.

      DO iNum = 1 TO NUM-ENTRIES(cViewerAttrs):
        FIND ttClassAttribute WHERE ttClassAttribute.tClassName = b_ryttDataField.tClassName AND
            ttClassAttribute.tAttributeLabel = ENTRY(iNum,cViewerAttrs) NO-ERROR.
        IF AVAILABLE ttClassAttribute THEN 
        DO: 
          hNewField = hNewBuffer:BUFFER-FIELD('t':U + ENTRY(iNum,cViewerAttrs)).
          IF ttClassAttribute.tAttributeValue NE hNewField:BUFFER-VALUE THEN
          DO:
            CREATE ttStoreAttribute.
            ASSIGN
              ttStoreAttribute.tAttributeParent = 'Master':U
              ttStoreAttribute.tAttributeLabel = ENTRY(iNum,cViewerAttrs)
              ttStoreAttribute.tCharacterValue = hNewField:BUFFER-VALUE.
          END.  /* if class value is different from new value */
        END.  /* avail class attribute */
      END.  /* do iNumAttr to number of viewer attributes */

      lIncludeListView = IF b_ryttDataField.tIncludeListView = b_ryttDataField.tIncludeView 
                         THEN ?
                         ELSE b_ryttDataField.tIncludeListView.
      FIND ttClassAttribute WHERE ttClassAttribute.tClassName = b_ryttDataField.tClassName AND
        ttClassAttribute.tAttributeLabel = 'IncludeInDefaultListView':U NO-ERROR.
      IF AVAILABLE ttClassAttribute AND 
           ttClassAttribute.tAttributeValue NE STRING(lIncludeListView) THEN 
      DO:
        CREATE ttStoreAttribute.
        ASSIGN
          ttStoreAttribute.tAttributeParent = 'Master':U
          ttStoreAttribute.tAttributeLabel  = 'IncludeInDefaultListView':U
          ttStoreAttribute.tLogicalValue    = lIncludeListView.
      END.

      FIND ttClassAttribute WHERE ttClassAttribute.tClassName = b_ryttDataField.tClassName AND
        ttClassAttribute.tAttributeLabel = 'IncludeInDefaultView':U NO-ERROR.
      IF AVAILABLE ttClassAttribute AND 
          ttClassAttribute.tAttributeValue NE STRING(b_ryttDataField.tIncludeView) THEN
      DO:
        CREATE ttStoreAttribute.
        ASSIGN
          ttStoreAttribute.tAttributeParent = 'Master':U
          ttStoreAttribute.tAttributeLabel  = 'IncludeInDefaultView':U
          ttStoreAttribute.tLogicalValue    = b_ryttDataField.tIncludeView.
      END.

    END.  /* if Add */
    ELSE IF b_ryttDataField.RowMod = 'U':U THEN
    DO:
      ASSIGN 
        hNewBuffer = BUFFER b_ryttDataField:HANDLE
        hOldBuffer = BUFFER old_ryttDataField:HANDLE.
    
      IF NOT hNewBuffer:BUFFER-COMPARE(hOldBuffer,'BINARY':U,'tEditMaster,tClassName,tFieldName,tInstanceName,tProductModule,tIncludeView,tIncludeListView':U) THEN
      DO:
        DO iNum = 1 TO hNewBuffer:NUM-FIELDS:
          ASSIGN 
            hNewField = hNewBuffer:BUFFER-FIELD(iNum)
            hOldField = hOldBuffer:BUFFER-FIELD(iNum).

          /* The attributes maintained directly on the viewer all happen to be character attributes,
             the logic to create ttStoreAttribute would need to change if a non-character attribute
             is added. */
          IF hNewField:BUFFER-VALUE NE hOldField:BUFFER-VALUE 
              AND LOOKUP(hNewField:NAME, 'tData-Type,tFormat,tLabel,tColumnLabel,tDefaultValue':U) > 0 THEN
          DO:
            FIND ttClassAttribute WHERE ttClassAttribute.tClassName = b_ryttDataField.tClassName AND
                ttClassAttribute.tAttributeLabel = SUBSTRING(hNewField:NAME, 2) NO-ERROR.
            IF AVAILABLE ttClassAttribute THEN 
            DO: 
              IF ttClassAttribute.tAttributeValue NE hNewField:BUFFER-VALUE THEN
              DO:
                CREATE ttStoreAttribute.
                ASSIGN
                  ttStoreAttribute.tAttributeParent = 'Master':U
                  ttStoreAttribute.tAttributeLabel = SUBSTRING(hNewField:NAME, 2)
                  ttStoreAttribute.tCharacterValue = hNewField:BUFFER-VALUE
                  cUpdatedAttributes               = cUpdatedAttributes + ',':U + 
                                                     SUBSTRING(hNewField:NAME, 2)
                  cUpdatedAttrValues               = cUpdatedAttrValues + CHR(3) +
                                                     IF hNewField:BUFFER-VALUE = ? THEN '?':U
                                                     ELSE hNewField:BUFFER-VALUE.
              END.  /* if class value is different from new value */
              ELSE DO:
                CREATE DeleteAttribute.
                ASSIGN
                  DeleteAttribute.tAttributeParent = 'Master':U
                  DeleteAttribute.tAttributeLabel  = SUBSTRING(hNewField:NAME, 2)
                  DeleteAttribute.tConstantValue   = NO.
              END.
            END.  /* avail class attribute */
          END.  /* if buffer value changed */        
        END.  /* do iNumField to number buffer fields */      
      END.  /* if buffer changed */

      lIncludeListView = IF b_ryttDataField.tIncludeListView = b_ryttDataField.tIncludeView 
                         THEN ?
                         ELSE b_ryttDataField.tIncludeListView.      
      FIND ttClassAttribute WHERE ttClassAttribute.tClassName = b_ryttDataField.tClassName AND
        ttClassAttribute.tAttributeLabel = 'IncludeInDefaultListView':U NO-ERROR.
      IF AVAILABLE ttClassAttribute AND 
        ttClassAttribute.tAttributeValue NE STRING(lIncludeListView) THEN 
      DO:
        CREATE ttStoreAttribute.
        ASSIGN
          ttStoreAttribute.tAttributeParent = 'Master':U
          ttStoreAttribute.tAttributeLabel  = 'IncludeInDefaultListView':U
          ttStoreAttribute.tLogicalValue    = lIncludeListView
          cUpdatedAttributes                = cUpdatedAttributes + ',IncludeInDefaultListView':U 
          cUpdatedAttrValues                = cUpdatedAttrValues + CHR(3) +
                                              IF lIncludeListView = ? THEN '?':U
                                              ELSE STRING(lIncludeListView).
      END.  /* if include view changed */
      ELSE DO:
        CREATE DeleteAttribute.
        ASSIGN
          DeleteAttribute.tAttributeParent = 'Master':U
          DeleteAttribute.tAttributeLabel  = 'IncludeInDefaultListView':U
          DeleteAttribute.tConstantValue   = NO.
      END.

      FIND ttClassAttribute WHERE ttClassAttribute.tClassName = b_ryttDataField.tClassName AND
        ttClassAttribute.tAttributeLabel = 'IncludeInDefaultView':U NO-ERROR.
      IF AVAILABLE ttClassAttribute AND 
        ttClassAttribute.tAttributeValue NE STRING(b_ryttDataField.tIncludeView) THEN 
      DO:
        CREATE ttStoreAttribute.
        ASSIGN
          ttStoreAttribute.tAttributeParent = 'Master':U
          ttStoreAttribute.tAttributeLabel  = 'IncludeInDefaultView':U
          ttStoreAttribute.tLogicalValue    = b_ryttDataField.tIncludeView
          cUpdatedAttributes                = cUpdatedAttributes + ',IncludeInDefaultView':U 
          cUpdatedAttrValues                = cUpdatedAttrValues + CHR(3) +
                                              IF b_ryttDataField.tIncludeView = ? THEN '?':U
                                              ELSE STRING(b_ryttDataField.tIncludeView).
      END.  /* if include view changed */
      ELSE DO:
        CREATE DeleteAttribute.
        ASSIGN
          DeleteAttribute.tAttributeParent = 'Master':U
          DeleteAttribute.tAttributeLabel  = 'IncludeInDefaultView':U
          DeleteAttribute.tConstantValue   = NO.
      END.
    END.  /* if update */
          
    /* Handle attributes updated with DPS */
    FOR EACH ttdpsAttr:
      FIND ttClassAttribute WHERE ttClassAttribute.tClassName = b_ryttDataField.tClassName AND
          ttClassAttribute.tAttributeLabel = ttdpsAttr.tLabel NO-ERROR.
      IF AVAILABLE ttClassAttribute AND 
        ttClassAttribute.tAttributeValue NE ttdpsAttr.tValue THEN 
      DO:
        CREATE ttStoreAttribute.
        ASSIGN
          ttStoreAttribute.tAttributeParent = 'Master':U
          ttStoreAttribute.tAttributeLabel  =  ttdpsAttr.tLabel
          cUpdatedAttributes                = cUpdatedAttributes + ',':U + 
                                              ttdpsAttr.tLabel
          cUpdatedAttrValues                = cUpdatedAttrValues + CHR(3) +
                                              IF ttdpsAttr.tValue = ? THEN '?':U
                                              ELSE ttdpsAttr.tValue.
        CASE ttdpsAttr.tDataType:
          WHEN 'CHARACTER':U OR WHEN 'CHAR':U THEN
            ttStoreAttribute.tCharacterValue = ttdpsAttr.tValue.
          WHEN 'DECIMAL':U OR WHEN 'DEC':U THEN
            ttStoreAttribute.tDecimalValue = DECIMAL(ttdpsAttr.tValue).
          WHEN 'INTEGER':U OR WHEN 'INT':U THEN
            ttStoreAttribute.tIntegerValue = INTEGER(ttdpsAttr.tValue).
          WHEN 'LOGICAL':U OR WHEN 'LOG':U THEN
            ttStoreAttribute.tLogicalValue = LOGICAL(ttdpsAttr.tValue).
          WHEN 'DATE':U THEN
            ttStoreAttribute.tDateValue = DATE(ttdpsAttr.tValue).
        END CASE.  
      END.  /* if include view changed */
      ELSE DO:
        CREATE DeleteAttribute.
        ASSIGN
          DeleteAttribute.tAttributeParent = 'Master':U
          DeleteAttribute.tAttributeLabel  = ttdpsAttr.tLabel
          DeleteAttribute.tConstantValue   = NO.
      END.  /* else do */
    END.  /* for each dps attribute */
    
    /* Make sure there's a TableName attribute for the DataFields.
       If there's already a value, then leave it alone. If not, then
       create a default value based on the entity name.
       
       Don't create this attribute for calculated fields.
     */
    if not lCalculatedField then
    do:
        if not can-find(ttStoreAttribute where ttStoreAttribute.tAttributeLabel = 'TableName') then
        do:
            /* We don't want to dispose of the TableName attribute */
            find DeleteAttribute where
                 DeleteAttribute.tAttributeLabel = 'TableName' and
                 DeleteAttribute.tAttributeParent = 'Master'
                 no-error.
            if available DeleteAttribute then
                delete DeleteAttribute.
            
            create ttStoreAttribute.
            assign ttStoreAttribute.tAttributeParent = 'Master'
                   ttStoreAttribute.tAttributeLabel  = 'TableName'
                   ttStoreAttribute.tCharacterValue  = entry(1, b_ryttDataField.tFieldName, '.').
            if b_ryttDataField.RowMod eq 'U' then
                assign cUpdatedAttributes = cUpdatedAttributes + ',':U
                                          + substring(hNewField:name, 2)
                       cUpdatedAttrValues = cUpdatedAttrValues + chr(3)
                                          + if hNewField:buffer-value eq ? then '?':U
                                            else hNewField:buffer-value.            
        end.    /* no TableName attribute available */
    end.    /* not a calc field. */

    ASSIGN hStoreAttributeBuffer = TEMP-TABLE ttStoreAttribute:HANDLE.

    RUN insertObjectMaster IN hRepDesignManager
        (INPUT b_ryttDataField.tFieldName,
         INPUT '':U,
         INPUT b_ryttDataField.tProductModule,
         INPUT b_ryttDataField.tClassName,
         INPUT b_ryttDataField.tClassName + ' ':U + b_ryttDataField.tFieldName,
         INPUT '':U,
         INPUT '':U,
         INPUT '':U,
         INPUT NO,
         INPUT YES,
         INPUT '':U,
         INPUT NO,
         INPUT '':U,
         INPUT '':U,
         INPUT '':U,
         INPUT ?,
         INPUT TABLE-HANDLE hStoreAttributeBuffer,
         OUTPUT dDataFieldObj).

    IF RETURN-VALUE <> '':U OR ERROR-STATUS:ERROR THEN
    DO:
      ERROR-STATUS:ERROR = NO.
      RETURN RETURN-VALUE.
    END.
    
    FOR EACH DeleteAttribute:
      ASSIGN DeleteAttribute.tAttributeParentObj = dDataFieldObj.
    END.

    hDeleteAttribute = TEMP-TABLE DeleteAttribute:DEFAULT-BUFFER-HANDLE.
    RUN RemoveAttributeValues IN hRepDesignManager
        (INPUT hDeleteAttribute,
         INPUT TABLE-HANDLE hUnknown) NO-ERROR.

    IF RETURN-VALUE <> '':U OR ERROR-STATUS:ERROR THEN
    DO:
      ERROR-STATUS:ERROR = NO.
      RETURN RETURN-VALUE.
    END.

  END.  /* if edit master */
  
  ASSIGN 
    hContainerSource = DYNAMIC-FUNCTION('getContainerSource':U IN TARGET-PROCEDURE)
    hDataSource      = DYNAMIC-FUNCTION('getDataSource':U IN hContainerSource).
  
  IF VALID-HANDLE(hDataSource) THEN
  DO:
    cEntityName = DYNAMIC-FUNCTION('columnValue':U IN hDataSource,
                                   INPUT 'entity_mnemonic_description':U).
    RUN retrieveDesignObject IN hRepDesignManager
        (INPUT cEntityName,
         INPUT '':U,              /* Default result codes */
         OUTPUT TABLE ttObject,
         OUTPUT TABLE ttPage,
         OUTPUT TABLE ttLink,
         OUTPUT TABLE ttUIEvent,
         OUTPUT TABLE ttObjectAttribute).

    FIND ttObject WHERE ttObject.tContainerSmartObjectObj = 0.
    IF AVAILABLE ttObject THEN
      dEntityObj = ttObject.tSmartObjectObj.

    IF b_ryttDataField.RowMod = 'U':U THEN
    DO:
      FIND ttObject WHERE ttOBject.tContainerSmartObjectObj > 0 AND 
        ttObject.tLogicalObjectName  = b_ryttDataField.tFieldName AND
        ttObject.tObjectInstanceName = old_ryttDataField.tInstanceName NO-ERROR.
      IF AVAILABLE ttObject THEN
        dInstanceObj = ttObject.tObjectInstanceObj.
    END.  /* if update */

    /* If the instance was renamed, it must be renamed BEFORE insertObjectInstance is
       invoked. */
    IF b_ryttDataField.RowMod = 'U':U AND 
        b_ryttDataField.tInstanceName NE old_ryttDataField.tInstanceName THEN
      RUN renameObjectInstance IN hRepDesignManager
          (INPUT dInstanceObj,
           INPUT b_ryttDataField.tInstanceName).

    RUN insertObjectInstance IN hRepDesignManager
        (INPUT dEntityObj,
         INPUT b_ryttDataField.tFieldName,
         INPUT '':U,
         INPUT b_ryttDataField.tInstanceName,
         INPUT b_ryttDataField.tClassName + ' ':U + b_ryttDataField.tFieldName,
         INPUT STRING(b_ryttDataField.tInstanceOrder),
         INPUT ?,
         INPUT b_ryttDataField.tInstanceOrder,
         INPUT NO,
         INPUT ?,
         INPUT TABLE-HANDLE hStoreAttributeBuffer,  
         OUTPUT dDataFieldObj,
         OUTPUT dInstanceObj)  NO-ERROR.

    IF RETURN-VALUE <> '':U OR ERROR-STATUS:ERROR THEN
    DO:
      ERROR-STATUS:ERROR = NO.
      RETURN RETURN-VALUE.
    END.
  END.  /* if valid data source */

  RUN validateDataFieldAttrs IN hRepDesignManager (INPUT b_ryttDataField.tFieldName, 
                                                   OUTPUT cInvalidAttrs,
                                                   OUTPUT cMessage).
  IF cMessage NE '':U THEN
    RETURN cMessage.
  
  cABDesignField = DYNAMIC-FUNCTION("getUserProperty":U IN TARGET-PROCEDURE, 
                                  INPUT "ABDesignField":U). 

  PUBLISH "DataFieldMasterChanged":U FROM TARGET-PROCEDURE
    (INPUT cABDesignField,
     INPUT LEFT-TRIM(cUpdatedAttributes, ',':U),
     INPUT LEFT-TRIM(cUpdatedattrValues, CHR(3))).

  EMPTY TEMP-TABLE ttdpsAttr.
END PROCEDURE.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

{&DB-REQUIRED-END}

/* ************************  Function Implementations ***************** */

&ANALYZE-SUSPEND _UIB-CODE-BLOCK _FUNCTION isFieldBlank DataLogicProcedure 
FUNCTION isFieldBlank RETURNS LOGICAL
  ( INPUT pcFieldValue AS CHARACTER ) :
/*------------------------------------------------------------------------------
  Purpose:  Checks whether a character field is blank
    Notes:  
------------------------------------------------------------------------------*/

  IF LENGTH(TRIM(pcFieldValue)) = 0 OR LENGTH(TRIM(pcFieldValue)) = ? THEN
    RETURN TRUE.
  ELSE
    RETURN FALSE.   /* Function return value. */

END FUNCTION.

/* _UIB-CODE-BLOCK-END */
&ANALYZE-RESUME

